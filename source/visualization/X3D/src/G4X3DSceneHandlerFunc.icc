//
// ********************************************************************
// * Licensec-mode and Disclaimer                                           *
// *                                                                  *
// * The  Geant4 software  is  copyright of the Copyright Holders  of *
// * the Geant4 Collaboration.  It is provided  under  the terms  and *
// * conditions of the Geant4 Software License,  included in the file *
// * LICENSE and available at  http://cern.ch/geant4/license .  These *
// * include a list of copyright holders.                             *
// *                                                                  *
// * Neither the authors of this software system, nor their employing *
// * institutes,nor the agencies providing financial support for this *
// * work  make  any representation or  warranty, express or implied, *
// * regarding  this  software system or assume any liability for its *
// * use.  Please see the license in the file  LICENSE  and URL above *
// * for the full disclaimer and the limitation of liability.         *
// *                                                                  *
// * This  code  implementation is the result of  the  scientific and *
// * technical work of the GEANT4 collaboration.                      *
// * By using,  copying,  modifying or  distributing the software (or *
// * any work based  on the software)  you  agree  to acknowledge its *
// * use  in  resulting  scientific  publications,  and indicate your *
// * acceptance of all terms of the Geant4 Software license.          *
// ********************************************************************
//
//
//
// G4X3DSceneHandlerFunc.icc
// Satoshi Tanaka & Yasuhide Sawada

//#define DEBUG_X3D_SCENE_FUNC

#include "G4VisManager.hh"

#include <sstream>

void G4X3DSCENEHANDLER::AddSolid(const G4Trd& trd)
{
#if defined DEBUG_X3D_SCENE_FUNC
  if (G4VisManager::GetVerbosity() >= G4VisManager::errors)
        G4cout << "***** AddSolid trd" << "\n" ;
#endif
	X3DBeginModeling () ;
	G4VSceneHandler::AddSolid(trd);
}

void G4X3DSCENEHANDLER::AddSolid(const G4Trap& trap)
{
#if defined DEBUG_X3D_SCENE_FUNC
  if (G4VisManager::GetVerbosity() >= G4VisManager::errors)
        G4cout << "***** AddSolid trap" << "\n" ;
#endif
	X3DBeginModeling () ;
	G4VSceneHandler::AddSolid(trap);
}

void G4X3DSCENEHANDLER::AddSolid(const G4Para& para)
{
#if defined DEBUG_X3D_SCENE_FUNC
  if (G4VisManager::GetVerbosity() >= G4VisManager::errors)
        G4cout << "***** AddSolid para" << "\n" ;
#endif
	X3DBeginModeling () ;
	G4VSceneHandler::AddSolid(para);
}

void G4X3DSCENEHANDLER::AddSolid(const G4Torus& torus )
{
#if defined DEBUG_X3D_SCENE_FUNC
  if (G4VisManager::GetVerbosity() >= G4VisManager::errors)
        G4cout << "***** AddSolid torus" << "\n" ;
#endif
	X3DBeginModeling () ;
	G4VSceneHandler::AddSolid(torus);
}


void G4X3DSCENEHANDLER::AddSolid(const G4VSolid& vsolid)
{
#if defined DEBUG_X3D_SCENE_FUNC
  if (G4VisManager::GetVerbosity() >= G4VisManager::errors)
        G4cout << "***** AddSolid vsolid" << "\n" ;
#endif
	X3DBeginModeling () ;
	G4VSceneHandler::AddSolid(vsolid);
}

void G4X3DSCENEHANDLER::AddSolid(const G4Tubs& tubs)
{
#if defined DEBUG_X3D_SCENE_FUNC
  if (G4VisManager::GetVerbosity() >= G4VisManager::errors)
	G4cout << "***** AddSolid tubs" << "\n" ;
#endif
	X3DBeginModeling () ;
	G4VSceneHandler::AddSolid(tubs) ;

}


void G4X3DSCENEHANDLER::AddSolid(const G4Cons& cons)
{
#if defined DEBUG_X3D_SCENE_FUNC
  if (G4VisManager::GetVerbosity() >= G4VisManager::errors)
        G4cout << "***** AddSolid cons" << "\n" ;
#endif
	X3DBeginModeling () ;
	G4VSceneHandler::AddSolid(cons) ;
}

void G4X3DSCENEHANDLER::AddSolid(const G4Box& box)
{
#if defined DEBUG_X3D_SCENE_FUNC
  if (G4VisManager::GetVerbosity() >= G4VisManager::errors)
	G4cout << "***** AddSolid box" << "\n" ;
#endif
	X3DBeginModeling () ;
//	G4VSceneHandler::AddSolid(box) ;
        fpVisAttribs = fpViewer->GetApplicableVisAttributes(fpVisAttribs);
        // Do not draw if not visible.
        if (!fpVisAttribs->IsVisible()) return;
        G4double dx = box.GetXHalfLength ();
        G4double dy = box.GetYHalfLength ();
        G4double dz = box.GetZHalfLength ();

	// Current Model
	const G4VModel* pv_model  = GetModel();
	G4String pv_name = "No model";
        if (pv_model) pv_name = pv_model->GetCurrentTag() ;

	// X3D codes are generated below

	fDest << "<!-- BOX: " << pv_name <<  " -->\n";

	if ( IsPVPickable() ) {

	 fDest << "<Anchor";
	 fDest << " description=" << "\"" << pv_name << "\"";
	 fDest << ">" << "\n";
	}

        bool transformed = SendTransformHeader();

        fDest << "<Shape>" << "\n";

	SendMaterialNode(fpVisAttribs);

	fDest << "\t" << "<Box size=\"" << 2*dx << " " << 2*dy << " " << 2*dz << "\" solid=\"false\"/>" << "\n";

	fDest << "</Shape>" << "\n";

        if( transformed ) fDest << "</Transform>" << "\n";

	if ( IsPVPickable() ) {
	 fDest << "</Anchor>"               << "\n"; // Anchor
	}
        
}


void G4X3DSCENEHANDLER::AddSolid(const G4Sphere& sphere)
{
#if defined DEBUG_X3D_SCENE_FUNC
  if (G4VisManager::GetVerbosity() >= G4VisManager::errors)
	G4cout << "***** AddSolid sphere" << "\n" ;
#endif
	X3DBeginModeling () ;
	G4VSceneHandler::AddSolid(sphere) ;
}

void G4X3DSCENEHANDLER::AddPrimitive(const G4Polyline& polyline)
{
#if defined DEBUG_X3D_SCENE_FUNC
  if (G4VisManager::GetVerbosity() >= G4VisManager::errors)
	G4cout << "***** AddPrimitive polyline" << "\n" ;
#endif 

        if (fProcessing2D) {
                static G4bool warned = false;
                if (!warned) {
                        warned = true;
                        G4Exception
                        ("G4X3DSCENEHANDLER::AddPrimitive (const G4Polyline&)",
                        "X3D-2001", JustWarning,
                        "2D polylines not implemented.  Ignored.");
                }
                return;
        }

	X3DBeginModeling () ;

	// X3D codes are generated below

	fDest << "<!-- POLYLINE -->\n";
	fDest << "<Shape>" << "\n";

	SendLineColor   ( polyline.GetVisAttributes() );

	fDest << "\t" << "<IndexedLineSet";

	G4int e, i;

	fDest << " coordIndex=\"";
	for (i = 0, e = polyline.size(); e; i++, e--) {
		if( i>0) fDest << " ";
		fDest << i << " ";
	}
	fDest << " -1";
	fDest << "\""       ; // coordIndex
	fDest << ">" << "\n"; // IndexedLineSet head
        
	fDest << "\t\t"   << "<Coordinate";


	fDest << " point=\"";
        
	for (i = 0, e = polyline.size(); e; i++, e--) {

		G4Point3D point = polyline[i];
		point.transform( fObjectTransformation );

		if(i!=0) fDest << " ";
		fDest <<                  point.x() << " ";
		fDest <<                  point.y() << " ";
		fDest <<                  point.z();

	} // for

	fDest << "\""; // point
	fDest << "/>"      << "\n"; // coord

	fDest << "\t" << "</IndexedLineSet>" << "\n"; // geometry IndexedLineSet

	fDest << "</Shape>" << "\n"; // Shape
}


void G4X3DSCENEHANDLER::AddPrimitive(const G4Polyhedron& polyhedron)
{
#if defined DEBUG_X3D_SCENE_FUNC
  if (G4VisManager::GetVerbosity() >= G4VisManager::errors)
	G4cout << "***** AddPrimitive(G4Polyhedron)" << "\n";
#endif

	if (polyhedron.GetNoFacets() == 0) return;

        if (fProcessing2D) {
                static G4bool warned = false;
                if (!warned) {
                        warned = true;
                        G4Exception
                        ("G4X3DSCENEHANDLER::AddPrimitive (const G4Polyhedron&)",
                        "X3D-2002", JustWarning,
                        "2D polyhedra not implemented.  Ignored.");
                }
                return;
        }

	X3DBeginModeling () ;

	// Transparency checking: If completely transparent, skip drawing 
	if ( GetPVTransparency() > 0.99 ) { return ; }

	// Current Model
	const G4VModel* pv_model  = GetModel();
	G4String pv_name = "No model";
        if (pv_model) pv_name = pv_model->GetCurrentTag() ;

	// X3D codes are generated below

	fDest << "<!-- SOLID: " << pv_name <<  " -->\n";

	if ( IsPVPickable() ) {

	 fDest << "<Anchor";
	 fDest << " description=" << "\"" << pv_name << "\"";
	 fDest << ">" << "\n";
	}

	fDest << "<Shape>" << "\n";

	SendMaterialNode();

	fDest << "\t" << "<IndexedFaceSet";

	fDest << " coordIndex=\"";

	// facet loop
	G4int f;
	for (f = polyhedron.GetNoFacets(); f; f--) {

		// edge loop  
		G4bool notLastEdge;
		G4int index = -1, edgeFlag = 1;
		if( f!=polyhedron.GetNoFacets() ) fDest << " ";
		do {
			notLastEdge = polyhedron.GetNextVertexIndex(index, edgeFlag);
			fDest << index - 1 << " ";
		} while (notLastEdge);
		fDest << "-1";
	}
	fDest << "\""; // coordIndex

	fDest << " solid=\"false\""; // draw backfaces
	fDest << ">" << "\n"; // end of IndexedFaceSet header
        
	fDest << "\t\t"   << "<Coordinate";
	fDest << " point=\"";
	G4int i, j;
	for (i = 1, j = polyhedron.GetNoVertices(); j; j--, i++) {
		G4Point3D point = polyhedron.GetVertex(i);

		point.transform( fObjectTransformation );

		if( i!=1 ) fDest << " ";
		fDest <<                   point.x() << " ";
		fDest <<                   point.y() << " ";
		fDest <<                   point.z() << " ";
	}
	fDest << "\""; // point
	fDest << " />"      << "\n"; // coord

	fDest << "\t" << "</IndexedFaceSet>"     << "\n"; // IndexFaceSet
	fDest << "" << "</Shape>"       << "\n"; // Shape

	if ( IsPVPickable() ) {
	 fDest << "</Anchor>"               << "\n"; // Anchor
	}

} 

#if 0
namespace {
   std::ostream& tprint(std::ostream& s, const G4Transform3D& t)
   {
        s
          << "Transform3D:\n"
          << t.xx() << "\t" << t.xy() << "\t" << t.xz() << "\t" << t.dx() << "\n"
          << t.yx() << "\t" << t.yy() << "\t" << t.yz() << "\t" << t.dy() << "\n"
          << t.zx() << "\t" << t.zy() << "\t" << t.zz() << "\t" << t.dz() << std::endl;
        return s;
   }
}
#endif

// bool because we need to skip closing tag if transform is not necessary
bool G4X3DSCENEHANDLER::SendTransformHeader()
{
	G4ThreeVector shift = fObjectTransformation.getTranslation();
        double        angle = 0.0;
        G4ThreeVector axis;
        if( !fProcessing2D ) {
		fObjectTransformation.getRotation().getAngleAxis(angle, axis);
	}
        if( angle < 1e-3 && shift.mag() < 1e-3 ) return false;

        fDest << "<Transform"; // start transfor head

        if( shift.mag() > 1e-3 ) {
          fDest << " translation=";
          fDest << "\"" << shift.x() << " " << shift.y() << " " << shift.z() << "\"";
        }
        if( angle > 1e-3 ) {
          fDest << " rotation=";
          fDest << "\"" << axis.x() << " " << axis.y() << " " << axis.z() << " " << angle << "\"";
        }
        fDest << ">" << "\n";                // end transfor head

        return true;
}

// bool because we need to skip closing tag if transform is not necessary
bool G4X3DSCENEHANDLER::SendTransformMarkerHeader(const G4VMarker& marker)
{
	G4ThreeVector shift = marker.GetPosition() + fObjectTransformation.getTranslation();
        double        angle = 0.0;
        G4ThreeVector axis;
        if( !fProcessing2D ) {
          fObjectTransformation.getRotation().getAngleAxis(angle, axis);
	}

        if( angle < 1e-3 && shift.mag() < 1e-3 ) return false;

        fDest << "\t" << "<Transform"; // start transfor head

        if( shift.mag() > 1e-3 ) {
          fDest << " translation=";
          fDest << "\"" << shift.x() << " " << shift.y() << " " << shift.z() << "\"";
        }
        if( angle > 1e-3 ) {
          fDest << " rotation=";
          fDest << "\"" << axis.x() << " " << axis.y() << " " << axis.z() << " " << angle << "\"";
        }
        fDest << ">" << "\n";                // end transfor head

        return true;
}

void G4X3DSCENEHANDLER::AddPrimitive( const G4Text& text) 
{
#if defined DEBUG_X3D_SCENE_FUNC
  if (G4VisManager::GetVerbosity() >= G4VisManager::errors)
	G4cout << "***** AddPrimitive text" << "\n" ;
#endif
#if 0
        if (fProcessing2D) {
                static G4bool warned = false;
                if (!warned) {
                        warned = true;
                        G4Exception
                        ("G4X3DSCENEHANDLER::AddPrimitive (const G4Text&)",
                        "X3D-2003", JustWarning,
                        "2D text not implemented.  Ignored.");
                }
                return;
        }
#endif
	X3DBeginModeling () ;

	// Transparency checking: If completely transparent, skip drawing 
	if ( GetPVTransparency() > 0.99 ) { return ; }

	// X3D codes are generated below

	fDest << "<!-- TEXT -->\n";

	if ( IsPVPickable() ) {
	 fDest << "<Anchor" ;
	 fDest << " description=" << "\"" << text.GetText() << "\"";
	 fDest << ">" << "\n";
	}

        const bool transformed = SendTransformMarkerHeader(text); // start of transform

	fDest << "<Shape>" << "\n";

	SendMarkerColor(text);

        // pxsize at 640px canvas, normalize to physical canvas size
        const G4double pxsize = 2*GetMarkerHalfSize(text);
        const G4double phsize = (pxsize/640.0)*2.0*GetScene()->GetExtent().GetExtentRadius();
	fDest << "\t" << "<Text"; // text head
	fDest << " string=\"" << text.GetText() << "\"";
        //	fDest << " solid=\"false\"";
        fDest << ">" << "\n";       // end text head

        // <fontstyle family="TYPEWRITER" style="BOLDITALIC" size="0.8"></fontstyle>
	fDest << "\t\t" << "<FontStyle"; // fontstyle
        //	fDest << " family=\"TYPEWRITER\"";
	fDest << " size=\"" << phsize <<"\"";
        fDest << "/>" << "\n";             // end fontstyle

        fDest << "\t" << "</Text>"; // end text
	fDest << "" << "</Shape>"       << "\n"; // Shape

	if( transformed ) {
            fDest << "</Transform>"       << "\n"; // end of transform
        }

	if ( IsPVPickable() ) {
	 fDest << "</Anchor>"               << "\n"; // Anchor
	}

        /*** You might need this
        ***/

  if (G4VisManager::GetVerbosity() >= G4VisManager::errors)
	G4cout <<
          "***** void G4X3DSCENEHANDLER::AddPrimitive( const G4Text& text )"
          " not implemented yet."
             << "\n";

  X3DBeginModeling () ;

}

void G4X3DSCENEHANDLER::AddPrimitive( const G4Circle& circle ) 
{
#if defined DEBUG_X3D_SCENE_FUNC
  if (G4VisManager::GetVerbosity() >= G4VisManager::errors)
	G4cout << "***** AddPrimitive circle" << "\n" ;
#endif

        if (fProcessing2D) {
                static G4bool warned = false;
                if (!warned) {
                        warned = true;
                        G4Exception
                        ("G4X3DSCENEHANDLER::AddPrimitive (const G4Circle&)",
                        "X3D-2004", JustWarning,
                        "2D circles not implemented.  Ignored.");
                }
                return;
        }

	X3DBeginModeling () ;

	// Information 
//	const char* info = NULL ;
	const char* info = circle.GetInfo() ;

	// Position and half size of circle
	G4double X, Y, Z ; GetMarkerWorldPosition( circle, &X, &Y, &Z ) ;
	G4double radius = GetMarkerHalfSize ( circle );

	// X3D codes are generated below
	fDest << "<!-- 3D MARKER (Circle) -->\n";
	fDest << "<Anchor";

	if( circle.GetInfo().isNull() ) {
		fDest << " description=" << "\"(" <<  X <<  "  " ;
		fDest <<                              Y <<  "  " ;
		fDest <<                              Z <<  ")\"";
	} else {
		fDest << " description=" << "\"" <<  info << "\"";
	}

	fDest << ">" << "\n";

	fDest << "<Transform";

	fDest << "   translation=\"" <<  X << " " << Y << " " << Z << "\"";

	fDest << ">"   << "\n";

	fDest << "<Shape>" << "\n";

	SendMarkerColor( circle );

	// send shape with size 
	fDest << "\t"   << "<Sphere";
	fDest <<      " radius=\"" << radius << "\"";
	fDest << "/>" << "\n";

	fDest << "</Shape>"       << "\n"; // Shape

	fDest << "</Transform>"             << "\n"; //  Transform
	
	fDest << "</Anchor>"               << "\n"; //  Anchor

}

void G4X3DSCENEHANDLER::AddPrimitive(const G4Square& square)
{
#if defined DEBUG_X3D_SCENE_FUNC
  if (G4VisManager::GetVerbosity() >= G4VisManager::errors)
	G4cout << "***** AddPrimitive square" << "\n" ;
#endif

        if (fProcessing2D) {
                static G4bool warned = false;
                if (!warned) {
                        warned = true;
                        G4Exception
                        ("G4X3DSCENEHANDLER::AddPrimitive (const G4Square&)",
                        "X3D-2005", JustWarning,
                        "2D squares not implemented.  Ignored.");
                }
                return;
        }

	X3DBeginModeling () ;

	// Information 
//	const char* info = NULL ;
	const char* info = square.GetInfo() ;

	// Position and size of square 
	G4double X, Y, Z ; GetMarkerWorldPosition  ( square, &X, &Y, &Z ) ;
	G4double radius   = GetMarkerHalfSize ( square );
	G4double diameter = 2.0 * radius ;

	// X3D codes are generated below
	fDest << "<!-- 3D MARKER (Square) -->\n";
	fDest << "<Anchor" << "\n";

	if( square.GetInfo().isNull() ) {
		fDest << " description=" << "\"(" <<  X <<  "  " ;
		fDest <<                              Y <<  "  " ;
		fDest <<                              Z <<  ")\"" << "\n";
	} else {
		fDest << " description=" << "\"" <<  info << "\"" << "\n";
	}

	fDest << " url=\"\" " << "\n";

	fDest << " >" << "\n";

	fDest << "<Transform" << "\n";

	fDest << "   translation=\"";
	fDest <<      X << " " << Y << " " << Z << "\"";

	fDest << ">"   << "\n"; // end Anchor head

	fDest << "<Shape>" << "\n";

	SendMarkerColor( square );

	// send shape with size 
	fDest << "\t"   << "<Box" << "\n";
	fDest <<       " size=\""   << diameter << " "  ;
	fDest                               << diameter << " "  ;
	fDest                               << diameter <<"\"" ;
	fDest << "/>"                        << "\n";

	fDest << "</Shape>"       << "\n"; //  Shape

	fDest << "</Transform>"             << "\n"; //  Transform
	
	fDest << "</Anchor>"               << "\n"; //  Anchor

}

void G4X3DSCENEHANDLER::BeginModeling()
{
#if defined DEBUG_X3D_SCENE_FUNC
  if (G4VisManager::GetVerbosity() >= G4VisManager::errors)
	G4cout << "***** BeginModeling" << "\n" ;
#endif
	G4VSceneHandler::BeginModeling();

}

void G4X3DSCENEHANDLER::EndModeling()
{
#if defined DEBUG_X3D_SCENE_FUNC
  if (G4VisManager::GetVerbosity() >= G4VisManager::errors)
	G4cout << "***** EndModeling " << "\n" ;
#endif
	G4VSceneHandler::EndModeling();
}

void G4X3DSCENEHANDLER::BeginPrimitives(const G4Transform3D& objectTransformation)
{
  G4VSceneHandler::BeginPrimitives (objectTransformation);
#if defined DEBUG_X3D_SCENE_FUNC
  if (G4VisManager::GetVerbosity() >= G4VisManager::errors)
	G4cout << "***** BeginPrimitives " << "\n" ;
#endif
	X3DBeginModeling(); 
}

void G4X3DSCENEHANDLER::EndPrimitives()
{
#if defined DEBUG_X3D_SCENE_FUNC
  if (G4VisManager::GetVerbosity() >= G4VisManager::errors)
	G4cout << "***** EndPrimitives " << "\n" ;
#endif
  G4VSceneHandler::EndPrimitives();
}

void G4X3DSCENEHANDLER::SendMaterialNode( const G4VisAttributes*  pVA )
{
	// Initialization of drawing parameters 	
	G4bool		flagWF       = false ; 
	G4double	TRANSPARENCY = GetPVTransparency() ;

	//  Wireframe or not
	const	G4ViewParameters& cur_view_param = fpViewer -> GetViewParameters ();
        if (pVA) {
          if (pVA->IsForceDrawingStyle() &&
              (pVA->GetForcedDrawingStyle() == G4VisAttributes::wireframe))
          {
            // wireframe style is assigned to this object
            flagWF = true ;

          } else if ( cur_view_param.GetDrawingStyle() == G4ViewParameters::wireframe )
          {
            // current viewing style is  wireframe 
            flagWF = true  ;
          }
        }

	// X3D codes are generated below
	if (!pVA) { 
		
		// Error recovery: Use default values of X3D browser
		fDest << "\t\t" ;
		fDest << "<Appearance> <Material/> </Appearance>";
		fDest << "\n";
		
	} else {

		const G4Color& color = pVA->GetColor();

		fDest << "\t\t"   << "<Appearance>" << "\n";
		fDest << "\t\t\t" <<      "<Material";

		// diffuse color
		fDest << " diffuseColor=\"";
		fDest <<                   color.GetRed()   << " " ;
		fDest <<                   color.GetGreen() << " " ;
		fDest <<                   color.GetBlue()  << "\""; 

		// wireframe is expressed as transparency
		if ( flagWF ) {
			fDest << " transparency=\"" << TRANSPARENCY << "\"";
		} else {
                	const G4double alpha = color.GetAlpha();
                        if( alpha>0.01 ) {
                              fDest << " transparency=\"" << alpha << "\"";
                        }
                  
                }

		fDest << "/>" << "\n"; // material
		fDest << "\t\t"   << "</Appearance>"      << "\n"; // appearance
	}

}


void G4X3DSCENEHANDLER::SendMaterialNode()
{
	SendMaterialNode
	( fpViewer->GetApplicableVisAttributes (fpVisAttribs) );
}


void G4X3DSCENEHANDLER::X3DBeginModeling()
{
	if (!IS_OPENED ) {
#if defined DEBUG_X3D_SCENE_FUNC
  if (G4VisManager::GetVerbosity() >= G4VisManager::errors)
	G4cout << "***** X3DBeginModeling (started)" << "\n" ;
#endif
		this->openFile();
	}
}

void G4X3DSCENEHANDLER::X3DEndModeling()
{
	if ( IS_OPENED ) {
#if defined DEBUG_X3D_SCENE_FUNC
  if (G4VisManager::GetVerbosity() >= G4VisManager::errors)
	G4cout << "***** X3DEndModeling (started)" << "\n" ;
#endif
		this->closeFile();
	}
}

void      G4X3DSCENEHANDLER::SendMarkerColor ( const G4VMarker& marker )
{
	fpVisAttribs = marker.GetVisAttributes();
	const G4Color& color = GetColor();

	fDest << "\t\t"     << "<Appearance>" << "\n";
	fDest << "\t\t\t"   <<      "<Material";
	fDest << " diffuseColor=\"";
	fDest <<                   color.GetRed()    << " " ;
	fDest <<                   color.GetGreen()  << " " ;
	fDest <<                   color.GetBlue()   << "\"";
	fDest << " emissiveColor=\"";
	fDest <<                   color.GetRed()    << " " ;
	fDest <<                   color.GetGreen()  << " " ;
	fDest <<                   color.GetBlue()   << "\"";
	fDest << "/>"              << "\n"; // end material
	fDest << "\t\t"     << "</Appearance>"                   << "\n"; // appearance

}

void      
G4X3DSCENEHANDLER::SendMarkerWorldPosition ( const G4VMarker& mark )
{
	G4Point3D point = mark.GetPosition();

	point.transform( fObjectTransformation );

	fDest << "   translation=\"";
	fDest <<      point.x() << " " << point.y() << " " << point.z() << "\"";

}

void  G4X3DSCENEHANDLER::GetMarkerWorldPosition    (	const G4VMarker&  mark , 
						double* pX             ,
						double* pY             ,
						double* pZ              ) 
{
	G4Point3D point = mark.GetPosition();

	point.transform( fObjectTransformation );

	*pX = point.x() ;
	*pY = point.y() ;
	*pZ = point.z() ;
}

G4double  G4X3DSCENEHANDLER::GetMarkerHalfSize ( const G4VMarker& mark ) 
{
	//----- return value ( marker radius in 3d units) 
	G4double size       = 1.0 ; // initialization

	//----- parameters to calculate 3d size from 2d size
	const double HALF_SCREEN_SIZE_2D = 300.0 ; // pixels
	double zoom_factor  = fpViewer->GetViewParameters().GetZoomFactor() ;
	if ( zoom_factor <=  0.0 ) { zoom_factor = 1.0 ; }
	double extent_radius_3d = GetScene()->GetExtent().GetExtentRadius() ;
	if ( extent_radius_3d <= 0.0 ) { extent_radius_3d = 1.0 ; } 

	//----- get marker radius in 3D units
	if        ( mark.GetWorldSize() > 0.0 ) {

		// get mark radius in 3D units
		size = 0.5 * mark.GetWorldSize()  ; 

	} else if ( mark.GetScreenSize() > 0.0 ) {

		// local
		double mark_radius_2d   = 0.5 * mark.GetScreenSize() ;

		// get mark radius in 3D units
		size \
		 = extent_radius_3d * ( mark_radius_2d / HALF_SCREEN_SIZE_2D );
		size *= zoom_factor ;

	} else {
		// local
		double mark_radius_2d \
		 = fpViewer->GetViewParameters().GetDefaultMarker().GetScreenSize();
		mark_radius_2d *= 0.1 ; // Magic number?

		// get mark radius in 3D units
		size \
		 = extent_radius_3d * ( mark_radius_2d / HALF_SCREEN_SIZE_2D );
		size *= zoom_factor ;
	}

		//----- global rescaling
	size *= fpViewer->GetViewParameters().GetGlobalMarkerScale(); 

		//----- return size
	return size ;

} 

void G4X3DSCENEHANDLER::SendLineColor ( const G4VisAttributes*  pVA )
{
	const G4Color& color = pVA->GetColor();


	fDest << "\t"   << "<Appearance>" << "\n";
	fDest << "\t\t" <<      "<Material";
	fDest << " diffuseColor=\"";
	fDest <<                   color.GetRed()    << " " ;
	fDest <<                   color.GetGreen()  << " " ;
	fDest <<                   color.GetBlue()   << "\"";
	fDest << " emissiveColor=\"";
	fDest <<                   color.GetRed()    << " " ;
	fDest <<                   color.GetGreen()  << " " ;
	fDest <<                   color.GetBlue()   << "\"";
	fDest <<      "/>"                  << "\n"; // material
	fDest << "\t"   << "</Appearance>"           << "\n"; // appearance
}

G4double      G4X3DSCENEHANDLER::SetPVTransparency ()
{

	G4double	TRANSPARENCY = 0.7   ;	// initialization
						
	if( std::getenv( "G4X3D_TRANSPARENCY" ) != NULL ) {

		// get a value from the env value
//		sscanf( getenv("G4X3D_TRANSPARENCY"), "%lg", &TRANSPARENCY ) ;
          std::istringstream iss( std::getenv("G4X3D_TRANSPARENCY") );
          iss >> TRANSPARENCY;

		// truncation
		TRANSPARENCY = std::fabs ( TRANSPARENCY ) ; 
		if ( TRANSPARENCY > 1.0 ) { TRANSPARENCY = 1.0 ; }
	} 

	fPVTransparency = TRANSPARENCY ;

	return fPVTransparency ;
}


void G4X3DSCENEHANDLER::ClearTransientStore() 
{
  // This is typically called after an update and before drawing hits
  // of the next event.  To simulate the clearing of "transients"
  // (hits, etc.) the detector is redrawn...
  if (fpViewer) {
    fpViewer -> SetView ();
    fpViewer -> ClearView ();
    fpViewer -> DrawView ();
  }
}


// End of file.
